name: Run Benchmarks

# Run on push for every branch including pull requests from forked repositories.
# And also allow this action to be triggered manually via a button in the GitHub UI.
on: [push, pull_request, workflow_dispatch]

jobs:
  build-loat-binary:
    runs-on: ubuntu-latest
    steps:    
      - name: Checkout LoAT Repository
        uses: actions/checkout@v4
        
      - name: Build LoAT Binary
        uses: addnab/docker-run-action@v3
        with:
          # Build LoAT binary inside the latest pushed base image:
          image: "${{ vars.DOCKERHUB_USERNAME }}/loat-base:latest"
          options: -v ${{ github.workspace }}:/LoAT
          shell: bash
          run: |
            mkdir -p /LoAT/build/release
            cd /LoAT/build/release
            cmake -DCMAKE_BUILD_TYPE=Release ../../
            make -j4

      - name: Export LoAT Binary
        uses: actions/upload-artifact@master
        with:
          name: loat-static
          path: build/release/loat-static

  chc-comp-benchmark:
    needs: [build-loat-binary]
    runs-on: ubuntu-latest
    strategy: 
      matrix: 
        include:
          - repo: 'chc-comp22-benchmarks'
            directory: 'LIA-Lin'
          - repo: 'chc-comp23-benchmarks'
            directory: 'LIA-lin'
    steps:
      - name: Checkout Benchmark Repository
        uses: actions/checkout@v4
        with:
          repository: chc-comp/${{ matrix.repo }}
          sparse-checkout: ${{ matrix.directory }}

      - name: Unpack
        run: gunzip ${{ matrix.directory }}/*.gz

      # retrieve previously built binary
      - name: Import LoAT Binary
        uses: actions/download-artifact@master
        with:
          name: loat-static
          path: /usr/local/bin/
     
      - name: Run Benchmark
        run: |
          # permissions are not preserved for artifacts:
          chmod +x /usr/local/bin/loat-static
        
          cd ${{ matrix.directory }}

          for filename in *.smt2; do
            printf "running ${filename} ... "
            start=`date +%s`

            set +e
            result=$(timeout 20 loat-static --mode reachability --format horn --proof-level 0 --engine adcl "${filename}")
            exit_status=$?
            set -e

            end=`date +%s`
            runtime=$((end-start))

            if [[ $exit_status -eq 0 ]]; then
              result=$(echo "$result" | head -n 1)
            elif [[ $exit_status -eq 124 ]]; then
              result="timeout"
            else
              result="error"
            fi

            printf "${result} after ${runtime}s\n"
          done
